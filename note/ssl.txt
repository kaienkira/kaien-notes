===============================================================================
-*- SSL KEY -*-
===============================================================================
# generate key in one command
openssl req -x509 -newkey rsa:4096 -sha256 \
        -keyout ssl.key -out ssl.crt -days 365 -nodes \
        -subj "/C=<CN>
               /ST=<State>
               /L=<Locality>
               /O=<Organization Name>
               /OU=<Organizational Unit Name>
               /CN=<Common Name>"


# client authentication 
# generate ca key
openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 365 -key ca.key -out ca.crt \
        -subj "/CN=enjoymi.com"

# generate server key
openssl genrsa -out server.key 4096
openssl req -new -key server.key -out server.csr \
        -subj "/CN=ssl.enjoymi.com"
# sign server key
openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key \
             -set_serial 01 -out server.crt

# generate client key
openssl genrsa -out client.key 4096
openssl req -new -key client.key -out client.csr \
        -subj "/CN=client.enjoymi.com"
# sign client key
openssl x509 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key \
             -set_serial 02 -out client.crt
# convert client key to pkcs
openssl pkcs12 -export -clcerts -passout pass: \
               -in client.crt -inkey client.key -out client.p12

===============================================================================
-*- CSR -*-
===============================================================================
# show csr file
openssl req -in <csr_file> -noout -text

# generate csr
## single domain
openssl req -new -sha256 -key domain.key -out domain.csr -subj "/CN=domain"
## multiple domain
cp /etc/ssl/openssl.cnf domain.conf
printf "[SAN]\nsubjectAltName=DNS:domain.com,DNS:www.domain.com" >> domain.conf
openssl req -new -sha256 -key domain.key -out domain.csr -subj "/" \
        -reqexts SAN -config domain.conf

===============================================================================
-*- X509 -*-
===============================================================================
# show crt file
openssl x509 -in <crt_file> -noout -text

===============================================================================
-*- PKCS -*-
===============================================================================
# dump PKCS#1 public key info
openssl rsa -pubin -in pkcs1.pem -text
-----BEGIN RSA PUBLIC KEY-----
-----END RSA PUBLIC KEY-----

# dump PKCS#8 public key info
openssl rsa -pubin -in pkcs8.pem -text
-----BEGIN PUBLIC KEY-----
-----END PUBLIC KEY-----

# convert to PKCS#8 private key
openssl pkcs8 -topk8 -inform PERM -in private_key.pem
        -outform PEM -nocrypt > pkcs8_private_key.txt

===============================================================================
-*- RSA -*-
===============================================================================
# 算法描述
随机生成大质数p,q
计算N = pq
计算r = φ(N) = (p - 1)(q - 1)
随机选择 1 < e < r, 且e,r互质
计算e的模反元素d(满足ed = 1 (mod r))
    使用扩展欧几里德算法计算ed + ry = 1得到d
公钥: (N, e)
私钥: (N, d)
加密: C = (P ^ e) (mod N)
解密: P = (C ^ d) (mod N)
    证明: P ^ (ed) = P (mod N)
    P ^ (1 + hφ(N)) = P * (P ^ φ(N)) ^ h = P (mod N)

# generate rsa key
openssl genrsa -out private_key.pem 4096
# show rsa key
openssl rsa -in domain.key -noout -text
    modulus:         N
    publicExponent:  e
    privateExponent: d
    prime1:          p
    prime2:          q
    exponent1:       d (mod (p - 1))
    exponent2:       d (mod (q - 1))
    coefficient:     (inverse of q) (mod p)
# generate public key from private key
openssl rsa -in private_key.pem -pubout -out public_key.pem

===============================================================================
-*- Block cipher mode of operation -*-
===============================================================================
ECB (Electronic Codebook)
CBC (Cipher Block Chaining)
    C(0) = Encrypt(P(0) ^ IV), C(n) = Encrypt(P(n) ^ C(n-1))
    P(0) = Decrypt(C(0)) ^ IV, P(n) = Decrypt(C(n)) ^ C(n-1)
PCBC (Propagating Cipher Block Chaining)
    C(0) = Encrypt(P(0) ^ IV), C(n) = Encrypt(P(n) ^ P(n - 1) ^ C(n - 1))
    P(0) = Decrypt(C(0)) ^ IV, P(n) = Decrypt(C(n)) ^ P(n - 1) ^ C(n - 1)
CFB (Cipher Feedback)
    C(0) = Encrypt(IV) ^ P(0), C(n) = Encrypt(C(n - 1)) ^ P(n)
    P(0) = Encrypt(IV) ^ C(0), P(n) = Encrypt(C(n - 1)) ^ C(n)
    ---------------------------------------------------------------------------
    S(0) = IV, C(0) = head(Encrypt(S(0)), x) ^ P(0),
    S(n) = (S(n - 1) << x) + C(n - 1), C(n) = head(Encrypt(S(n)), x) ^ P(n)
    S(0) = IV, P(0) = head(Encrypt(S(0)), x) ^ C(0),
    S(n) = (S(n - 1) << x) + C(n - 1), P(n) = head(Encrypt(S(n)), x) ^ C(n)
OFB (Output Feedback)
    O(0) = Encrypt(IV), C(0) = O(0) ^ P(0)
    O(n) = Encrypt(O(n - 1)), C(n) = O(n) ^ P(n)
    ---------------------------------------------------------------------------
    O(0) = Encrypt(IV), P(0) = O(0) ^ C(0)
    O(n) = Encrypt(O(n - 1)), P(n) = O(n) ^ C(n)
CTR (Counter Mode)
    N(0) = IV, C(0) = Encrypt(N(0)) ^ P(0)
    N(n) = N(n - 1) + 1, C(n) = Encrypt(N(n)) ^ P(n)
    ---------------------------------------------------------------------------
    N(0) = IV, P(0) = Encrypt(N(0)) ^ C(0)
    N(n) = N(n - 1) + 1, P(n) = Encrypt(N(n)) ^ C(n)
