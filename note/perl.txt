===============================================================================
-*- Variable -*-
===============================================================================
scalar($)
    *. undef
    *. 数字
    *. 字符串
    *. 引用
array(@)
    @array = (1, 2, 3);
    $array[0]
hash(%)
    %hash = (0 => 1);
    $hash{0}
    *. '=>'等价于','
reference(\)

*. 没有内置的布尔类型, 以下被认为是false
    [] undef
    [] 0
    [] ""
    [] "0"
*. 当一个函数声称它返回"true"，返回值往往是1,
   声称它返回"false", 返回值往往是一个空字符串""

*. 数值运算符   <,  >,  <=, >=, ==, !=, <=>, +, *
*. 字符串运算符 lt, gt, le, ge, eq, ne, cmp, ., x
*. 列表不能嵌套, array也同样无法包含其他array和hash作为其元素, 它们只能包含scalar
*. 用方括号声明匿名array, 而用花括号声明匿名hash,
   这两种方法返回的是声明的匿名数据结构的引用

===============================================================================
-*- Control Flow -*-
===============================================================================
*. if.. elsif .. else ..
*. unless.. else..
*. while() {}
*. until() {}
*. do {} while();
*. do {} until();
*. for() {}
*. foreach my $i ( @array ) {}
   foreach my $i (0 .. n) {}
   foreach my $k (keys %hash) {}
   foreach my $k (sort keys %hash) {}
   foreach (@array) { $_ }
* next (loop continue)
* last (loop break)

===============================================================================
-*- Function -*-
===============================================================================
sub func {
}
*. 在子程序中，参数被保存在内置array变量@_中
*. 以引用方式传递参数, 子程序中用到的变量或值不是实参的副本, 它们本身就是实参

===============================================================================
-*- Built-In Variable -*-
===============================================================================
$_     默认迭代器

===============================================================================
-*- Array Functions -*-
===============================================================================
push @array $element, ...
pop @array
unshift @array $element, ...
shift @array
join(":", @array)
reverse @array
map {} @array
grep {} @array
sort {} @array

===============================================================================
-*- RE -*-
===============================================================================
*. 匹配
$string =~ m/regex/
*. 替换
$string =~ s/regex/replacement/

===============================================================================
-*- Module && Package -*-
===============================================================================
*. 因为模块在被加载时会自顶向下执行，你需要在结尾处返回一个true表示加载成功
*. .pl文件不应该包含package声明
*. .pm文件必须包含且仅包含一个package声明, 且包名与它的文件名, 所在的位置一致
*. use只是BEGIN块的伪装, 同样的警告对此也适用
   use语句必须总是放在文件开头, 并且永远不要放在条件分支里
