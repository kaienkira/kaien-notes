===============================================================================
cargo new --bin --name <package_name> <path>
cargo init
cargo build --release
cargo run --release
===============================================================================


===============================================================================
-*- Primitive type -*-
-------------------------------------------------------------------------------
bool
char
     represents a single Unicode scalar value
     Rust's char is not a single byte, but four
i8,i16,i32,i64
u8,u16,u32,u64
isize,usize
    size depends on the size of a pointer of the underlying machine
f32,f64
str
array [T; N]
    fixed-size list of elements of the same type
    indexing: a[0]
    let a = [0; 5] // equal to [0,0,0,0,0]
tuple (...)
    indexing: t.0, t.1, t.2 ...
slice &[T]
    a reference to (or 'view' into) another data structure
function

reference &T &mut T

===============================================================================
-*- Struct -*-
-------------------------------------------------------------------------------
Update syntax
    let p1 = Point { x: 0, y: 0 };
    let p2 = Point { x: 1, .. p };
Tuple structs
    struct Point(i32, i32, i32);
Unit-like structs
    struct Point;
    struct Point {}

===============================================================================
-*- Enum -*-
-------------------------------------------------------------------------------
Sum type
    *. A value of the enum can match any of the variants.
       For this reason, an enum is sometimes called a `sum type`,
    *. the set of possible values of the enum is the sum of
       the sets of possible values for each variant.
Tagged union

===============================================================================
-*- Unsized Types -*-
-------------------------------------------------------------------------------
*. We can only manipulate an instance of an unsized type via a pointer.
   An &[T] works fine, but a [T] does not
*. Variables and arguments cannot have dynamically sized types
*. Only the last field in a struct may have a dynamically sized type;
   the other fields must not.
*. Enum variants must not have dynamically sized types as data

===============================================================================
-*- Statement and Expression -*-
-------------------------------------------------------------------------------
There are two kinds of statements in Rust:
1) declaration statements
2) expression statements

*. a let can only begin a statement, not an expression
*. the value of an assignment is an empty tuple ()

===============================================================================
-*- Comment -*-
-------------------------------------------------------------------------------
//  comment
/// doc comment
//! module comment

===============================================================================
-*- Control flow -*-
-------------------------------------------------------------------------------
*. An if without an else always results in () as the value

if ... {
} else {
}

loop {
}

while ... {
}

for i in iterator {
}

Loop labels
'label:
    continue 'label;

===============================================================================
-*- Function -*-
-------------------------------------------------------------------------------
*. Using a return as the last line of a function works
   but is considered poor style
*. diverging functions: functions that do not return
    fn diverges() -> ! {}

===============================================================================
-*- Pattern -*-
-------------------------------------------------------------------------------
_             any case
a | b         multiple patterns
T { .. }      destructure
ref r         reference
ref mut r
1 ... n       range
e @ 1 ... n   binding
a if cond     guard

===============================================================================
-*- Ownership -*-
-------------------------------------------------------------------------------
RAII
Move semantics
Copy trait

*. variable bindings 'have ownership' of what they are bound to
   when a binding goes out of scope, Rust will free the bound resources
*. Rust ensures that there is exactly one binding to any given resource
*. All primitive types implement the Copy trait and
   their ownership is therefore not moved
*. any borrow must last for a scope no greater than that of the owner
*. you may have one or the other of these two kinds of borrows,
   but not both at the same time
    1)one or more references (&T) to a resource
    2)exactly one mutable reference (&mut T)
*. the mutable borrow prevents subsequent moves, borrows, or modification
   until the borrow ends
*. Non-lexical lifetimes(NLL)
   a reference's scope starts from where it is introduced
   and continues through the last time that reference is used

===============================================================================
* Rust has two main types of strings: &str and String
  &str is called "string slices"
    [] statically allocated string
    [] have a fixed size, and cannot be mutated
  String 
    [] heap-allocated string
    [] commonly created by converting from a string slice
       using the to_string method
    [] Strings will coerce into &str with an &
*. All strings are guaranteed to be a valid encoding of UTF-8 sequences
*. Viewing a String as a &str is cheap,
   but converting the &str to a String involves allocating memory
*. Because strings are valid UTF-8, strings do not support indexing

===============================================================================
#![allow(dead_code)]
#![allow(unused_variables)]
#![no_implicit_prelude]
#![no_std]
#![no_main]
===============================================================================
#[panic_handler]
#[start]
===============================================================================
#[inline(always)]
#[must_use]
#[must_use = "reason"]
===============================================================================
