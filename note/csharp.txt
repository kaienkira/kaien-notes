===============================================================================
The binary comparison and branch operations only work on
* int32
* int64
* native int
* native floating point
* object
* managed reference
These operands are 32-bits or 64-bits on any current CPU core,
ensuring the JIT compiler can generate efficient machine code.
===============================================================================
process constant overflow

byte b = (255 << 1) & 0xff
byte b = unchecked((byte)(255 << 1));
===============================================================================
*. using statement
ensures the correct use of IDisposable objects
*. dispose pattern

using System;

class BaseClass : IDisposable
{
   // Flag: Has Dispose already been called?
   bool disposed = false;

   // Public implementation of Dispose pattern callable by consumers.
   public void Dispose()
   { 
      Dispose(true);
      GC.SuppressFinalize(this);           
   }

   // Protected implementation of Dispose pattern.
   protected virtual void Dispose(bool disposing)
   {
      if (disposed)
         return; 

      if (disposing) {
         // Free any other managed objects here.
         //
      }

      // Free any unmanaged objects here.
      //
      disposed = true;
   }

   ~BaseClass()
   {
      Dispose(false);
   }
}
===============================================================================
new 约束指定泛型类声明中的任何类型参数都必须有公共的无参数构造函数
===============================================================================

===============================================================================
-*- Enumerable, enumerator, yield -*-
===============================================================================
public interface IEnumerable
{
    IEnumerator GetEnumerator();
}
   
public interface IEnumerator
{
    bool MoveNext();
    void Reset();

    Object Current { get; }
}

IEnumerator func()
{
    yield return <expr>
    yield break
}

===============================================================================
-*- Attribute -*-
===============================================================================
Conditional
Obsolete
===============================================================================

===============================================================================
-*- Multithread -*-
===============================================================================
ManualResetEvent
System.Threading.Monitor


*. lock is just shortcut for Monitor.Enter with try + finally and Monitor.Exit
*. the lack of condition variable makes it impossible to distinguish
   between the various cases where threads wait on the same shared resource/lock,
   but for different reasons.
   All waiting threads are place on a big waiting queue for that shared resource,
   which undermines efficiency.
===============================================================================

===============================================================================
export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1
export DOTNET_CLI_TELEMETRY_OPTOUT=1

===============================================================================
#nullable enable

===============================================================================
<PropertyGroup>
  <Nullable>enable</Nullable>
</PropertyGroup>
===============================================================================
